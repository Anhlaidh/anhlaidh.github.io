<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Oxide</title>
    <link>http://blog.oxide.ink/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Oxide</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 01 Jul 2021 20:58:36 +0000</lastBuildDate><atom:link href="http://blog.oxide.ink/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法</title>
      <link>http://blog.oxide.ink/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 01 Jul 2021 20:58:36 +0000</pubDate>
      
      <guid>http://blog.oxide.ink/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</guid>
      <description>基础 工具 对数器
一个想要测的方法a 实现复杂度不好但是容易实现的方法b 实现一个随机样本产生器 方法a和方法b相同的随机样本,看看得到的结果是否一样 如果一个随机样本使得比对结果不一致,打印样本进行人工干预,改对方法a和方法b 当样本数量很多时对比测试依然正确,可以确定方法a已经正确 比较器
比较器的实质是重载比较运算符 比较器可以很好的应用在特殊标准的排序上 比较器可以很好的应用在根据特殊标准排序的结构上 PriorityQueue 小根堆转大根堆 写代码变得异常容易,还用于泛型编程 运算 异或运算,二进制无进位相加 性质:0^N=N,N^N=0 满足交换律和结合律(同一批数异或答案一样,无论顺序) ab互换 a = a^b b = a^b a = a^b ab必须指向不同内存 提取最右侧1 N&amp;amp;((~N)+1) N与((N取反)+1) 排序 桶排序 数据状况强相关 -计数排序 设数组,累加 基数排序 非负十进制 添0,入桶出桶 权重逆着 排序算法的稳定性 稳定性是指同样大小的样本再排序之后不会改变相对次序 对基础类型来说,稳定性毫无意义 对非基础类型来说,稳定性有重要意义 有些算法可以实现成稳定的,而有些排序算法无论如何都实现不成稳定的 有稳定性: -处理相等情况时的策略 冒泡排序 插入排序 归并排序 桶排序 十分稳定 基数排序 计数排序 无稳定性: 选择排序 快排 partition过程必破坏稳定性 堆排 序算法总结 不基于比较的排序,对样本数据有严格的要求,不易改写 基于比较的排序,只要规定好两个样本怎么比大小就可以直接复用 基于比较的排序,时间复杂度的极限是O(NlogN) 时间复杂度O(NlogN),额外空间复杂度低于O(N),且稳定的基于比较的排序是不存在的 为了绝对的速度选快排,为了省空间选堆排,为了稳定选归并 小规模用常数项小的排序,例如插入排序,大规模用调度优秀的排序,如快排 常见的坑 归并排序的额外空间复杂度可以变成O(1),&amp;ldquo;归并排序 内部缓存法&amp;rdquo;,但是将变得不再稳定 -&amp;gt;直接堆排 &amp;ldquo;原地归并排序&amp;quot;是垃圾帖,会让时间复杂度变成O(N^2) -&amp;gt;插入排序 快排稳定性改进,&amp;ldquo;01 stable sort&amp;rdquo;,但是会对样本数据要求更多 -&amp;gt;桶排序 在整数数组中,请把奇数放在数组左边,偶数放在数组右边,要求所有奇数之间,偶数之间的原始相对次序不变 时间复杂度做到O(N).</description>
    </item>
    
  </channel>
</rss>
